<!DOCTYPE html>
<html>
<head>
  <title>Ambiente Virtual</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="cache-control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="expires" content="0">
  <style>
    canvas {
      width: 100%;
      height: 100%;
      touch-action: none;
    }
    html, body {
      margin: 0;
      overflow: hidden;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
  <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
  <script src="https://cdn.babylonjs.com/recast.js"></script>
  <script src="https://cdn.babylonjs.com/ammo.js"></script>
  <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
  <script src="https://cdn.babylonjs.com/cannon.js"></script>
  <script src="https://cdn.babylonjs.com/Oimo.js"></script>
  <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
  <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
  <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
  <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      var canvas = document.getElementById("renderCanvas");
      var engine = new BABYLON.Engine(canvas, true);

      var createScene = function () {
            var scene = new BABYLON.Scene(engine);
            scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.CannonJSPlugin());
            // Habilitar detecção de colisão na cena
            scene.collisionsEnabled = true;
            
            var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.7;

            // Crie uma imagem HDRI e atribua-a ao ambiente da cena
            var hdrTexture = new BABYLON.CubeTexture("https://www.babylonjs-playground.com/textures/environment.dds", scene);
            scene.environmentTexture = hdrTexture;

            // Luz adicional para iluminar o teto
            var ceilingLight = new BABYLON.HemisphericLight("ceilingLight", new BABYLON.Vector3(0, -1, 0), scene);
            ceilingLight.intensity = 0.5;

            var ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 10, height: 10 }, scene);
            var groundMaterial = new BABYLON.StandardMaterial("groundMaterial", scene);
            groundMaterial.diffuseTexture = new BABYLON.Texture("./img/chao.jpg", scene);
            // Ajustar as coordenadas de textura (UVs)
            groundMaterial.diffuseTexture.uScale = 6.5; // Aumenta a escala horizontal da textura
            groundMaterial.diffuseTexture.vScale = 6.5; // Aumenta a escala vertical da textura
            ground.material = groundMaterial;
            ground.checkCollisions = true;
            ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.5, restitution: 0.7 }, scene);

            
            // Importe o modelo do professor usando ImportMeshAsync
            const professorPromise = BABYLON.SceneLoader.ImportMeshAsync("", "./img/", "professor.glb", scene);

            // Quando o modelo for carregado (a promessa for resolvida), você pode acessar os meshes carregados
            professorPromise.then((result) => {
                // O resultado é um objeto que contém informações sobre os meshes carregados, como 'meshes', 'particleSystems', etc.
                const meshes = result.meshes;

                // Certifique-se de que o modelo foi carregado corretamente e contenha meshes
                if (meshes.length > 0) {
                    // Neste exemplo, iremos posicionar o professor no ponto (0, 0, 0) da cena
                    meshes[0].position = new BABYLON.Vector3(0, 0, 0);

                    // Você também pode rotacionar o mesh, se necessário
                    meshes[0].rotation = new BABYLON.Vector3(0, Math.PI / 2, 0);

                    // Você pode escalar o mesh se necessário
                    meshes[0].scaling = new BABYLON.Vector3(1.3, 1.3, 1.3);
                } else {
                    console.error("Nenhum mesh foi carregado. Verifique o caminho do arquivo .glb ou o conteúdo do modelo.");
                }
            }).catch((error) => {
                console.error("Ocorreu um erro ao carregar o modelo: ", error);
            });                       

            // Importe o modelo do professor usando ImportMeshAsync
            const alunaPromise = BABYLON.SceneLoader.ImportMeshAsync("", "./img/", "aluna.glb", scene);

            // Quando o modelo for carregado (a promessa for resolvida), você pode acessar os meshes carregados
            alunaPromise.then((result) => {
                // O resultado é um objeto que contém informações sobre os meshes carregados, como 'meshes', 'particleSystems', etc.
                const meshes = result.meshes;

                // Certifique-se de que o modelo foi carregado corretamente e contenha meshes
                if (meshes.length > 0) {
                    // Neste exemplo, iremos posicionar o professor no ponto (0, 0, 0) da cena
                    meshes[0].position = new BABYLON.Vector3(1, 1.55, 0);

                    // Você também pode rotacionar o mesh, se necessário
                    // meshes[0].rotation = new BABYLON.Vector3(0, Math.PI / 2, 0);

                    // Você pode escalar o mesh se necessário
                    meshes[0].scaling = new BABYLON.Vector3(1, 1, 1);
                } else {
                    console.error("Nenhum mesh foi carregado. Verifique o caminho do arquivo .glb ou o conteúdo do modelo.");
                }
            }).catch((error) => {
                console.error("Ocorreu um erro ao carregar o modelo: ", error);
            });  

            // Importe o modelo do professor usando ImportMeshAsync
            const computador2Promise = BABYLON.SceneLoader.ImportMeshAsync("", "./img/", "computador2.glb", scene);

            // Quando o modelo for carregado (a promessa for resolvida), você pode acessar os meshes carregados
            computador2Promise.then((result) => {
              // O resultado é um objeto que contém informações sobre os meshes carregados, como 'meshes', 'particleSystems', etc.
              const meshes = result.meshes;

              // Certifique-se de que o modelo foi carregado corretamente e contenha meshes
              if (meshes.length > 0) {
                  // Neste exemplo, iremos posicionar o professor no ponto (0, 0, 0) da cena
                  meshes[0].position = new BABYLON.Vector3(-4, 1, 2);

                  // Você também pode rotacionar o mesh, se necessário
                  meshes[0].rotation = new BABYLON.Vector3(0, Math.PI / 2, 0);

                  // Você pode escalar o mesh se necessário
                  meshes[0].scaling = new BABYLON.Vector3(1, 1, 1);
              } else {
                  console.error("Nenhum mesh foi carregado. Verifique o caminho do arquivo .glb ou o conteúdo do modelo.");
              }
            }).catch((error) => {
              console.error("Ocorreu um erro ao carregar o modelo: ", error);
            });

            // Importe o modelo do professor usando ImportMeshAsync
            const planta1Promise = BABYLON.SceneLoader.ImportMeshAsync("", "./img/", "planta1.glb", scene);

            // Quando o modelo for carregado (a promessa for resolvida), você pode acessar os meshes carregados
            planta1Promise.then((result) => {
              // O resultado é um objeto que contém informações sobre os meshes carregados, como 'meshes', 'particleSystems', etc.
              const meshes = result.meshes;

              // Certifique-se de que o modelo foi carregado corretamente e contenha meshes
              if (meshes.length > 0) {
                  // Neste exemplo, iremos posicionar o professor no ponto (0, 0, 0) da cena
                  meshes[0].position = new BABYLON.Vector3(-4.6, 0, -1);

                  // Você também pode rotacionar o mesh, se necessário
                  //meshes[0].rotation = new BABYLON.Vector3(0, Math.PI / 2, 0);

                  // Você pode escalar o mesh se necessário
                  meshes[0].scaling = new BABYLON.Vector3(.15, .15, .15);
              } else {
                  console.error("Nenhum mesh foi carregado. Verifique o caminho do arquivo .glb ou o conteúdo do modelo.");
              }
            }).catch((error) => {
              console.error("Ocorreu um erro ao carregar o modelo: ", error);
            });  

            // Importe o modelo do professor usando ImportMeshAsync
            const planta2Promise = BABYLON.SceneLoader.ImportMeshAsync("", "./img/", "planta2.glb", scene);

            // Quando o modelo for carregado (a promessa for resolvida), você pode acessar os meshes carregados
            planta2Promise.then((result) => {
              // O resultado é um objeto que contém informações sobre os meshes carregados, como 'meshes', 'particleSystems', etc.
              const meshes = result.meshes;

              // Certifique-se de que o modelo foi carregado corretamente e contenha meshes
              if (meshes.length > 0) {
                  // Neste exemplo, iremos posicionar o professor no ponto (0, 0, 0) da cena
                  meshes[0].position = new BABYLON.Vector3(4.6, 0, -1);

                  // Você também pode rotacionar o mesh, se necessário
                  //meshes[0].rotation = new BABYLON.Vector3(0, Math.PI / 2, 0);

                  // Você pode escalar o mesh se necessário
                  meshes[0].scaling = new BABYLON.Vector3(1.3, 1.3, .6);
              } else {
                  console.error("Nenhum mesh foi carregado. Verifique o caminho do arquivo .glb ou o conteúdo do modelo.");
              }
            }).catch((error) => {
              console.error("Ocorreu um erro ao carregar o modelo: ", error);
            });               


            // Importe o modelo do professor usando ImportMeshAsync
            const petPromise = BABYLON.SceneLoader.ImportMeshAsync("", "./img/", "pet.glb", scene);

            // Quando o modelo for carregado (a promessa for resolvida), você pode acessar os meshes carregados
            petPromise.then((result) => {
              // O resultado é um objeto que contém informações sobre os meshes carregados, como 'meshes', 'particleSystems', etc.
              const meshes = result.meshes;

              // Certifique-se de que o modelo foi carregado corretamente e contenha meshes
              if (meshes.length > 0) {
                  // Neste exemplo, iremos posicionar o professor no ponto (0, 0, 0) da cena
                  meshes[0].position = new BABYLON.Vector3(-6.3,2, 3.7);

                  // Você também pode rotacionar o mesh, se necessário
                  meshes[0].rotation = new BABYLON.Vector3(0, 0, 0);
                  
                  // Você pode escalar o mesh se necessário
                  meshes[0].scaling = new BABYLON.Vector3(1.0, 1.0, 1.0);
              } else {
                  console.error("Nenhum mesh foi carregado. Verifique o caminho do arquivo .glb ou o conteúdo do modelo.");
              }
            }).catch((error) => {
              console.error("Ocorreu um erro ao carregar o modelo: ", error);
            }); 
            // Importe o modelo do professor usando ImportMeshAsync
            const computador1Promise = BABYLON.SceneLoader.ImportMeshAsync("", "./img/", "computador1.glb", scene);

            // Quando o modelo for carregado (a promessa for resolvida), você pode acessar os meshes carregados
            computador1Promise.then((result) => {
              // O resultado é um objeto que contém informações sobre os meshes carregados, como 'meshes', 'particleSystems', etc.
              const meshes = result.meshes;

              // Certifique-se de que o modelo foi carregado corretamente e contenha meshes
              if (meshes.length > 0) {
                  // Neste exemplo, iremos posicionar o professor no ponto (0, 0, 0) da cena
                  meshes[0].position = new BABYLON.Vector3(8, 3.5, 1);

                  // Você também pode rotacionar o mesh, se necessário
                  meshes[0].rotation = new BABYLON.Vector3(0, Math.PI / 2, 0);

                  // Você pode escalar o mesh se necessário
                  meshes[0].scaling = new BABYLON.Vector3(1, 1, 1);
              } else {
                  console.error("Nenhum mesh foi carregado. Verifique o caminho do arquivo .glb ou o conteúdo do modelo.");
              }
            }).catch((error) => {
              console.error("Ocorreu um erro ao carregar o modelo: ", error);
            }); 

          // Importe o modelo do professor usando ImportMeshAsync
          const portaEsquerdaPromise = BABYLON.SceneLoader.ImportMeshAsync("", "./img/", "porta.glb", scene);

          // Quando o modelo for carregado (a promessa for resolvida), você pode acessar os meshes carregados
          portaEsquerdaPromise.then((result) => {
            // Certifique-se de que o modelo foi carregado corretamente e contenha meshes
            if (result.meshes && result.meshes.length > 0) {
              // O resultado é um objeto que contém informações sobre os meshes carregados, como 'meshes', 'particleSystems', etc.
              const meshes = result.meshes;

              // Neste exemplo, iremos posicionar a porta no ponto (0, 0, 0) da cena
              meshes[0].position = new BABYLON.Vector3(-4.99, 0, 0);

              // Você também pode rotacionar o mesh, se necessário
              meshes[0].rotation = new BABYLON.Vector3(0, - Math.PI / 2, 0);

              // Você pode escalar o mesh se necessário
              meshes[0].scaling = new BABYLON.Vector3(1.3, 1, 1);
              // Crie um box envolvendo a porta
              } else {
              console.error("Nenhum mesh foi carregado. Verifique o caminho do arquivo .glb ou o conteúdo do modelo.");
            }
          }).catch((error) => {
            console.error("Ocorreu um erro ao carregar o modelo: ", error);
          });

          // Importe o modelo do professor usando ImportMeshAsync
          const portaDireitaPromise = BABYLON.SceneLoader.ImportMeshAsync("", "./img/", "porta.glb", scene);

          // Quando o modelo for carregado (a promessa for resolvida), você pode acessar os meshes carregados
          portaDireitaPromise.then((result) => {
            // Certifique-se de que o modelo foi carregado corretamente e contenha meshes
            if (result.meshes && result.meshes.length > 0) {
              // O resultado é um objeto que contém informações sobre os meshes carregados, como 'meshes', 'particleSystems', etc.
              const meshes = result.meshes;

              // Neste exemplo, iremos posicionar a porta no ponto (0, 0, 0) da cena
              meshes[0].position = new BABYLON.Vector3(4.90, 0, 0);

              // Você também pode rotacionar o mesh, se necessário
              meshes[0].rotation = new BABYLON.Vector3(0, - Math.PI / 2, 0);

              // Você pode escalar o mesh se necessário
              meshes[0].scaling = new BABYLON.Vector3(1.2, 1, 1);
              // Crie um box envolvendo a porta
              } else {
              console.error("Nenhum mesh foi carregado. Verifique o caminho do arquivo .glb ou o conteúdo do modelo.");
            }
          }).catch((error) => {
            console.error("Ocorreu um erro ao carregar o modelo: ", error);
          });          
 
            var paredeMaterial = new BABYLON.StandardMaterial("paredeMaterial", scene);
            paredeMaterial.diffuseTexture = new BABYLON.Texture("./img/textura_parede.jpg", scene);

            paredeMaterial.diffuseTexture.uScale = 1; // Aumenta a escala horizontal da textura
            paredeMaterial.diffuseTexture.vScale = 1; // Aumenta a escala vertical da textura

            var leftWall = BABYLON.MeshBuilder.CreateBox("leftWall", { width: 0.1, height: 3.5, depth: 10 }, scene);
            leftWall.material = paredeMaterial;
            leftWall.position.x = -5;
            leftWall.position.y = 1;
            leftWall.checkCollisions = true;
            leftWall.physicsImpostor = new BABYLON.PhysicsImpostor(leftWall, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.5, restitution: 0.7 }, scene);

            var rightWall = BABYLON.MeshBuilder.CreateBox("rightWall", { width: 0.1, height: 3.5, depth: 10 }, scene);
            rightWall.material = paredeMaterial;
            rightWall.position.x = 5;
            rightWall.position.y = 1;
            rightWall.checkCollisions = true;
            rightWall.physicsImpostor = new BABYLON.PhysicsImpostor(rightWall, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.5, restitution: 0.7 }, scene);

            var backWall = BABYLON.MeshBuilder.CreateBox("backWall", { width: 10, height: 3.5, depth: 0.1 }, scene);
            backWall.material = paredeMaterial;
            backWall.position.z = 5;
            backWall.position.y = 1;
            backWall.checkCollisions = true;
            backWall.physicsImpostor = new BABYLON.PhysicsImpostor(backWall, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.5, restitution: 0.7 }, scene);

            var frontWall = BABYLON.MeshBuilder.CreateBox("frontWall", { width: 10, height: 3.5, depth: 0.1 }, scene);
            frontWall.material = paredeMaterial;
            frontWall.position.z = -5;
            frontWall.position.y = 1;
            frontWall.checkCollisions = true;
            frontWall.physicsImpostor = new BABYLON.PhysicsImpostor(frontWall, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.5, restitution: 0.7 }, scene);
            
            // Criar a textura "paisagem.jpg"
            var frontMaterial = new BABYLON.StandardMaterial("paredeMaterial", scene);
            frontMaterial.diffuseTexture = new BABYLON.Texture("img/paisagem.jpg", scene);

            frontMaterial.diffuseTexture.uScale = 1; // Aumenta a escala horizontal da textura
            frontMaterial.diffuseTexture.vScale = 1; // Aumenta a escala vertical da textura
            // Criar a frontDoor como uma parte recortada da frontWall
            var doorWidth = 4;
            var doorHeight = 2.5;
            var doorDepth = 0.1;
            var frontDoor = BABYLON.MeshBuilder.CreateBox("frontDoor", { width: doorWidth, height: doorHeight, depth: doorDepth }, scene);
            frontDoor.position.z = -4.95; // A posição z é a mesma da frontWall, mas um pouco mais à frente
            frontDoor.position.y = 1;
            frontDoor.position.x = 0; // Centralizando a porta na frontWall
            frontDoor.checkCollisions = true;
            frontDoor.physicsImpostor = new BABYLON.PhysicsImpostor(frontDoor, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.5, restitution: 0.7 }, scene);
            frontDoor.material = frontMaterial;

            frontDoor.actionManager = new BABYLON.ActionManager(scene);

            // Crie um gatilho para o evento de clique do mouse
            frontDoor.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
            BABYLON.ActionManager.OnPickTrigger, // Gatilho para o evento de clique do mouse
            function (evt) {
            // Ação a ser executada quando o clique ocorrer na porta
            console.log("Clique na porta detectado!");
            // Aqui você pode redirecionar para outra página, exibir informações, etc.
            // Por exemplo:
            window.location.href = "../index.html";
            })); 
                       
            var doorMaterial = new BABYLON.StandardMaterial("doorMaterial", scene);
            doorMaterial.diffuseTexture = new BABYLON.Texture("img/letreiro.jpg", scene);
            doorMaterial.diffuseTexture.vScale = 1;
            doorMaterial.diffuseTexture.uScale = 1;

            var letreiroEsquerdo = BABYLON.MeshBuilder.CreateBox("leftDoor", { width: 0.1, height: .3, depth: 1.1 }, scene);
            letreiroEsquerdo.position.x = -4.95;
            letreiroEsquerdo.position.y = 2.35;
            letreiroEsquerdo.checkCollisions = true;
            //letreiroEsquerdo.physicsImpostor = new BABYLON.PhysicsImpostor(leftDoor, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.5, restitution: 0.7 }, scene);
            letreiroEsquerdo.material = doorMaterial; 

            var leftDoor = BABYLON.MeshBuilder.CreateBox("leftDoor", { width: 0.5, height: 3, depth: 1.4 }, scene);
            leftDoor.position.x = -4.6;
            leftDoor.position.y = 0.35;
            leftDoor.checkCollisions = true;
            leftDoor.physicsImpostor = new BABYLON.PhysicsImpostor(leftDoor, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.5, restitution: 0.7 }, scene);
            // Definir o material transparente
            var materialInvisivel = new BABYLON.StandardMaterial("materialInvisivel", scene);
            materialInvisivel.alpha = 0; // Configurar a transparência para 0 (totalmente transparente)
            leftDoor.material = materialInvisivel; 

            leftDoor.actionManager = new BABYLON.ActionManager(scene);

            // Crie um gatilho para o evento de clique do mouse
            leftDoor.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
            BABYLON.ActionManager.OnPickTrigger, // Gatilho para o evento de clique do mouse
            function (evt) {
            // Ação a ser executada quando o clique ocorrer na porta
            console.log("Clique na porta detectado!");
            // Aqui você pode redirecionar para outra página, exibir informações, etc.
            // Por exemplo:
            window.location.href = "../sala_de_aula_com_livro/sala_de_aula_livro_python.html";
            })); 

            var letreiroDiretto = BABYLON.MeshBuilder.CreateBox("leftDoor", { width: 0.1, height: .3, depth: 1.1 }, scene);
            letreiroDiretto.position.x = 4.95;
            letreiroDiretto.position.y = 2.35;
            letreiroDiretto.checkCollisions = true;
            //letreiroDiretto.physicsImpostor = new BABYLON.PhysicsImpostor(leftDoor, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.5, restitution: 0.7 }, scene);
            letreiroDiretto.material = doorMaterial; 

            var rightDoor = BABYLON.MeshBuilder.CreateBox("rightDoor", { width: 0.3, height: 2, depth: 1.4 }, scene);
            rightDoor.position.x = 4.6;
            rightDoor.position.y = 1;
            rightDoor.checkCollisions = true;
            rightDoor.physicsImpostor = new BABYLON.PhysicsImpostor(rightDoor, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.5, restitution: 0.7 }, scene);
            // Definir o material transparente
            var materialInvisivel = new BABYLON.StandardMaterial("materialInvisivel", scene);
            materialInvisivel.alpha = 0; // Configurar a transparência para 0 (totalmente transparente)
            rightDoor.material = materialInvisivel;

            rightDoor.actionManager = new BABYLON.ActionManager(scene);

            // Crie um gatilho para o evento de clique do mouse
            rightDoor.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
            BABYLON.ActionManager.OnPickTrigger, // Gatilho para o evento de clique do mouse
            function (evt) {
            // Ação a ser executada quando o clique ocorrer na porta
            console.log("Clique na porta detectado!");
            // Aqui você pode redirecionar para outra página, exibir informações, etc.
            // Por exemplo:
            window.location.href = "../sala_de_aula_com_livro/sala_de_aula_livro_automacao.html";
            })); 

           // Criar um plano para o letreiro
            var signWidth = 2;
            var signHeight = 1.8;
            var signDepth = 1;

            var signEsquerdo = BABYLON.MeshBuilder.CreatePlane("sign", { width: signWidth, height: signHeight }, scene);
            signEsquerdo.position.x = -4.85;
            signEsquerdo.position.y = 2.35;
            signEsquerdo.rotation = new BABYLON.Vector3(0, -Math.PI / 2, 0);
            signEsquerdo.checkCollisions = true;


            // Criar o texto 'Introdução à Programação'
            var advancedTextureEsquerdo = BABYLON.GUI.AdvancedDynamicTexture.CreateForMesh(signEsquerdo);
            var textBlockEsquerdo = new BABYLON.GUI.TextBlock();
            textBlockEsquerdo.text = "Programação";
            textBlockEsquerdo.color = "white";
            textBlockEsquerdo.fontSize = 85;
            textBlockEsquerdo.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            textBlockEsquerdo.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
            advancedTextureEsquerdo.addControl(textBlockEsquerdo);
            
            var signDireito = BABYLON.MeshBuilder.CreatePlane("sign", { width: signWidth, height: signHeight }, scene);
            signDireito.position.x = 4.85;
            signDireito.position.y = 2.35;
            signDireito.rotation = new BABYLON.Vector3(0, Math.PI / 2, 0);
            signDireito.checkCollisions = true;

            // Criar o texto 'Introdução à Programação'
            var advancedTextureDireito = BABYLON.GUI.AdvancedDynamicTexture.CreateForMesh(signDireito);
            var textBlockDireito = new BABYLON.GUI.TextBlock();
            textBlockDireito.text = "Automação";
            textBlockDireito.color = "white";
            textBlockDireito.fontSize = 85;
            textBlockDireito.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            textBlockDireito.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
            advancedTextureDireito.addControl(textBlockDireito);
            
            var windowMaterial = new BABYLON.StandardMaterial("windowMaterial", scene);
            windowMaterial.diffuseTexture = new BABYLON.Texture("img/janela.jpg", scene);

            var windowWidth = 2; // Largura da janela
            var windowHeight = 2; // Altura da janela

            var windowMesh = BABYLON.MeshBuilder.CreatePlane("windowMesh", { width: windowWidth, height: windowHeight }, scene);
            windowMesh.position.z = 4.9; // Posição na frente da parede frontal
            windowMesh.position.y = 1.5; // Altura em que a janela será colocada na parede
            windowMesh.material = windowMaterial;

            var windowMaterial1 = new BABYLON.StandardMaterial("windowMaterial1", scene);
            windowMaterial1.diffuseTexture = new BABYLON.Texture("img/janela1.jpg", scene);

            var windowWidth1 = 2; // Largura da janela
            var windowHeight1 = 2; // Altura da janela

            var windowMesh1 = BABYLON.MeshBuilder.CreatePlane("windowMesh1", { width: windowWidth1, height: windowHeight1 }, scene);
            windowMesh1.position.z = 4.9; // Posição na frente da parede frontal
            windowMesh1.position.y = 1.5; // Altura em que a janela será colocada na parede
            windowMesh1.position.x = -2.5;
            windowMesh1.material = windowMaterial1;

            var windowMaterial2 = new BABYLON.StandardMaterial("windowMaterial2", scene);
            windowMaterial2.diffuseTexture = new BABYLON.Texture("img/janela2.jpg", scene);

            var windowWidth2 = 2; // Largura da janela
            var windowHeight2 = 2; // Altura da janela

            var windowMesh2 = BABYLON.MeshBuilder.CreatePlane("windowMesh2", { width: windowWidth2, height: windowHeight2 }, scene);
            windowMesh2.position.z = 4.9; // Posição na frente da parede frontal
            windowMesh2.position.y = 1.5; // Altura em que a janela será colocada na parede
            windowMesh2.position.x = 2.5;
            windowMesh2.material = windowMaterial2;

            var ceilingMaterial = new BABYLON.StandardMaterial("ceilingMaterial", scene);
            ceilingMaterial.diffuseTexture = new BABYLON.Texture("img/teto.jpg", scene);
            ceilingMaterial.diffuseTexture.uScale = 20; // Aumenta a escala horizontal da textura
            ceilingMaterial.diffuseTexture.vScale = 20; // Aumenta a escala vertical da textura

            var ceiling = BABYLON.MeshBuilder.CreateBox("ceiling", { width: 10, height: 0.1, depth: 10 }, scene);
            ceiling.position.y = 2.7; // Posicione acima das paredes
            ceiling.checkCollisions = true;
            ceiling.physicsImpostor = new BABYLON.PhysicsImpostor(ceiling, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.5, restitution: 0.7 }, scene);
            ceiling.material = ceilingMaterial;

          
            var camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 1.4, -3.5), scene);
            //camera.attachControl(canvas, true);
            camera.checkCollisions = true;
            camera.applyGravity = false;
            //camera.fov = 1.5; // Reduza o campo de visão para manter a câmera pequena
                        
            // Configuração inicial
            var cameraSpeed = 0.03; // Defina a velocidade do movimento da câmera
            var cameraMoveDirection = new BABYLON.Vector3(0, 0, 0);
            var cameraMoveEnabled = true; // Habilitar/desabilitar movimentação da câmera
            var cameraRotationSensitivity = 0.001; // Sensibilidade da rotação horizontal da câmera
            var isDragging = false; // Variável para indicar se o mouse está arrastando
            var collidableObjects = []; // Array para armazenar objetos colidíveis (paredes, portas, etc.)

            // Adicione os objetos colidíveis ao array collidableObjects
            //collidableObjects.push(ceiling,leftWall,backWall,rightDoor,leftDoor,windowMesh,windowMesh1,windowMesh2); // Adicione todos os objetos colidíveis à lista
            
             // Create an invisible sphere to represent the camera's collision shape
            var cameraBox = BABYLON.MeshBuilder.CreateSphere("cameraBox", { diameter: 1 }, scene);
            cameraBox.position = camera.position; // Set the cameraBox position to match the camera
            cameraBox.isVisible = false; // Hide the cameraBox from rendering
            cameraBox.physicsImpostor = new BABYLON.PhysicsImpostor(cameraBox, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 0, friction: 0.5, restitution: 0.7 }, scene);

            // Function to check collisions and apply smooth movement
            function checkCollisions() {
                if (!cameraMoveEnabled) return;

                var newPos = camera.position.add(cameraMoveDirection.multiplyByFloats(cameraSpeed, cameraSpeed, cameraSpeed));
                var ray = new BABYLON.Ray(camera.position, cameraMoveDirection, cameraSpeed);
                var hit = scene.pickWithRay(ray, function (mesh) {
                    return collidableObjects.indexOf(mesh) !== -1;
                });

                if (hit.hit) {
                    // Collision detected, don't allow movement
                    cameraMoveDirection.set(0, 0, 0);
                }

                // Restrict camera movement within the boundaries of the ground
                var groundHalfWidth = ground.scaling.x * 3.5;
                var groundHalfHeight = ground.scaling.z * 3.5;

                // Clamp the camera position within the ground boundaries
                newPos.x = Math.min(Math.max(newPos.x, -groundHalfWidth), groundHalfWidth);
                newPos.z = Math.min(Math.max(newPos.z, -groundHalfHeight), groundHalfHeight);

                camera.position.copyFrom(newPos);
                }

              // Evento de teclado para controlar a movimentação da câmera
              scene.onKeyboardObservable.add(function (kbInfo) {
                  var keyCode = kbInfo.event.key;

                  // Calcula a direção do movimento da câmera com base na rotação
                  var cameraDirection = camera.getDirection(BABYLON.Axis.Z);
                  var cameraMoveDirection = new BABYLON.Vector3(cameraDirection.x, 0, cameraDirection.z);

                  if (keyCode === "ArrowUp" || keyCode === "w") {
                    camera.position.addInPlace(cameraMoveDirection.multiplyByFloats(cameraSpeed, cameraSpeed, cameraSpeed));
                  } else if (keyCode === "ArrowDown" || keyCode === "s") {
                    camera.position.addInPlace(cameraMoveDirection.multiplyByFloats(-cameraSpeed, -cameraSpeed, -cameraSpeed));
                  } else if (keyCode === "ArrowLeft" || keyCode === "a") {
                    var cameraSideDirection = camera.getDirection(BABYLON.Axis.X);
                    camera.position.addInPlace(cameraSideDirection.multiplyByFloats(-cameraSpeed, -cameraSpeed, -cameraSpeed));
                  } else if (keyCode === "ArrowRight" || keyCode === "d") {
                    var cameraSideDirection = camera.getDirection(BABYLON.Axis.X);
                    camera.position.addInPlace(cameraSideDirection.multiplyByFloats(cameraSpeed, cameraSpeed, cameraSpeed));
                  }
                  cameraMoveEnabled = cameraMoveDirection.lengthSquared() > 0;
            });

            

              // Evento para parar o movimento da câmera quando a tecla é liberada
              window.addEventListener("keyup", function (event) {
                      var keyCode = event.key;

                    if ((keyCode === "ArrowUp" || keyCode === "w") && cameraMoveDirection.z === 1) {
                        cameraMoveDirection.z = 0;
                    } else if ((keyCode === "ArrowDown" || keyCode === "s") && cameraMoveDirection.z === -1) {
                        cameraMoveDirection.z = 0;
                    } else if ((keyCode === "ArrowLeft" || keyCode === "a") && cameraMoveDirection.x === -1) {
                        cameraMoveDirection.x = 0;
                    } else if ((keyCode === "ArrowRight" || keyCode === "d") && cameraMoveDirection.x === 1) {
                        cameraMoveDirection.x = 0;
                    }

                    // Habilitar o movimento da câmera somente se a velocidade for maior que zero
                    cameraMoveEnabled = cameraMoveDirection.lengthSquared() > 0;
            });          
          
              // Controle de rotação horizontal da câmera com o mouse
              // Evento de clique do mouse (quando o usuário pressiona ou solta o botão do mouse)
              var onPointerDown = function (evt) {
                if (evt.button === 0) {
                  isDragging = true; // Começa o arraste do mouse quando o botão esquerdo é pressionado
                }
              };

              var onPointerUp = function (evt) {
                if (evt.button === 0) {
                  isDragging = false; // Para o arraste do mouse quando o botão esquerdo é solto
                }
              };

              // Evento de movimento do mouse (quando o usuário arrasta o mouse)
              var onPointerMove = function (evt) {
                if (isDragging) {
                  // Calcula a mudança horizontal do mouse
                  var deltaX = evt.movementX || evt.mozMovementX || evt.webkitMovementX || 0;

                  // Atualiza a rotação horizontal da câmera
                  camera.rotation.y -= deltaX * cameraRotationSensitivity;
                }
              };

              // Adiciona os eventos de clique e movimento do mouse à janela (window)
              window.addEventListener("pointerdown", onPointerDown);
              window.addEventListener("pointerup", onPointerUp);
              window.addEventListener("pointermove", onPointerMove); 

              // Registro da função de verificação de colisões no loop de renderização da cena
              scene.onBeforeRenderObservable.add(checkCollisions);

                                 

            //Create GUI
            var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
            
            // Criar um painel para conter o texto            
                  


            /* const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
            
            const panel = new BABYLON.GUI.StackPanel();
            panel.width = "220px";
            panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
            advancedTexture.addControl(panel); */
                    
           /*  const header = new BABYLON.GUI.TextBlock();
            header.text = "Material Properties";
            header.height = "20px";
            header.color = "white";
            panel.addControl(header); */
            
            /* const addSlider = (
                text,
                min,
                max,
                value,
                onValueChanged
            ) => {
                const textBlock = new BABYLON.GUI.TextBlock();
                textBlock.height = "20px";
                textBlock.text = text + value;
                panel.addControl(textBlock);
                const slider = new BABYLON.GUI.Slider();
                slider.minimum = min;
                slider.maximum = max;
                slider.value = value;
                slider.height = "20px";
                slider.onValueChangedObservable.add(function (value) {
                onValueChanged(value);
                textBlock.text = text + value.toFixed(2);
                });
                panel.addControl(slider);
            }; */
            
            /* addSlider("Metallic: ", 0, 1, pbr.metallic, (value) => {
                pbr.metallic = value;
            });
            addSlider("Roughness: ", 0, 1, pbr.roughness, (value) => {
                pbr.roughness = value;
            });
            addSlider("Alpha: ", 0, 1, pbr.alpha, (value) => {
                pbr.alpha = value;
            }); */
                      
                       
            /* let counter = 0;
            let a = 0;
            scene.registerBeforeRender(() => {
                counter += 0.01;
                iff.forEach((iff, index) => {
                iff.rotation.y = counter / 2;
                //iff.rotation.z = counter / 2;
                });
                a += 0.005;
                            
                pbr.subSurface.tintColor.g = Math.sin(a) * 0.5 + 0.5;
                pbr.subSurface.tintColor.b = pbr.subSurface.tintColor.g;
            });  */
            
            

            return scene;
          };

      var scene = createScene();
      engine.runRenderLoop(function () {
        scene.render();
      });

      window.addEventListener("resize", function () {
        engine.resize();
      });
    });
  </script>
</body>
</html>